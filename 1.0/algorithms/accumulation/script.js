window.onload = function () {
document.getElementById('io_arrow').innerHTML = "&rarr;";
document.getElementById('level').innerHTML = "&#9733; &#9733; ";
document.getElementById('ptitle').innerHTML = "區間和";
document.getElementById('ptitle_en').innerHTML = "Range Sum";
document.getElementById('input_comment').innerHTML = "整數序列與 Q 個區間<ul><li>序列的元素數N &le; 100,000</li><li>Q &le; 100,000</li></ul>";
document.getElementById('output_comment').innerHTML = "各指定區間的區間和";
document.getElementById('motivation').innerHTML = "對資料進行預處理，可以提高未來特定運算的執行效率，這是一個非常重要的觀念， 就像之前介紹過的二元搜尋法，只要事先將資料排序，就可以進行快速搜尋。這個概念 同樣可以應用在整數序列的求和問題，只要事先進行資料的預處理（算出序列的累積 和），之後就可以快速求得每段的區間和。";
document.getElementById('description').innerHTML = "從 1 個整數序列與該序列的 Q 個區間，求出各區間的區間和。";
document.getElementById('input_panel').innerHTML = '<img src="../../problems/range_sum/input.svg" width="340"/>';
document.getElementById('output_panel').innerHTML = '<img src="../../problems/range_sum/output.svg" width="340"/>';
document.getElementById('algorithm_icon').innerHTML = '<img src="../../icons/algorithms/accumulation.svg" width="100"/>';
document.getElementById('atitle').innerHTML = "累積和";
document.getElementById('atitle_en').innerHTML = "Accumulation";
document.getElementById('abstract').innerHTML = "在回答 Q 個區間和之前，我們要先求出整數序列的累積和。本節會使用 2 個陣列， 一個用來儲存輸入的資料，一個用來計算累積和。";
document.getElementById('explanation').innerHTML = "累積和也可以只用 1 個陣列變數 A 來計算，只要以計算結果覆蓋掉元素上原本儲存的 輸入資料即可，不過本節是以另一個陣列變數 AC 來記錄 A 的累積和。輸入資料時，請 跳過 A 的第 0 個索引，從索引 1 的位置開始輸入。AC 的第 0 個元素需初始化為 0。<br/><br/>計算累積和時，起始位置為索引 1。計算方式是從 i 為 1 開始，計算 AC[i] ← AC[i-1]  + A[i]。到了第 i 次計算時，AC[i] 中就會記錄從 A[1] 到 A[i] 的總和。<br/><br/>計算出累積和後，即可藉由 AC[r] - AC[ ll -1] 求出 A[ ll ] 到 A[r] 的總和，回答區間 [ ll , r]  的區間和。這是因為 AC[r] 為 A[1] 到 A[r] 的總和，而 AC[ ll -1] 為 A[1] 到 A[ ll -1] 的總 和，因此兩者相減即可求出區間和。";
document.getElementById('note').innerHTML = "如果使用較單純的演算法，不預先計算累積和，而是針對每個區間逐一計算區間和， 則時間複雜度將達 O(NQ)。<br/>使用累積和，則各區間和皆只需要 1 次減法即可求得，時間複雜度為 O(1)。因此先 計算累積和，再利用累積和來計算 Q 個區間和的演算法，時間複雜度為 O(N+Q)。";
document.getElementById('application').innerHTML = "進階排序演算法中的計數排序法（Counting Sort），就用到了累積和的概念。  此外，累積和也能應用在一維與二維（多維）的重疊問題，請看接下來兩節的說明。";
document.getElementById('structure').innerHTML = '<tr><td style="text-align:center;width:100"><img src="../../icons/structures/A1D.svg" /><br/><br/></td><td class="frame">&nbsp;<img height="160" class="frame_svg" valign="middle" src="space_st.svg" />&nbsp;</td></tr><tr><td></td><td class="caption">2 個一維陣列與 1 個單節點</td></tr>';
document.getElementById('variable').innerHTML = '<tr><th class="scene_desc" colspan="3">資料</th></tr><tr><td class="symbol"><img src="variable_A.svg" /></td><td>輸入的整數序列</td><td class="code">A</td></tr><tr><td class="symbol"><img src="variable_AC.svg" /></td><td>整數序列的累積和</td><td class="code">AC</td></tr><tr><td class="symbol"><img src="variable_sum.svg" /></td><td>區間和</td><td class="code">sum</td></tr>';
document.getElementById('formula').innerHTML = '<tr><th class="scene_desc" colspan="3">輸入</th></tr><tr><td class="symbol"><img src="formula_input.svg" /></td><td>載入整數序列。</td><td class="code"></td></tr><tr><td class="symbol"><img src="formula_init.svg" /></td><td>將累積和最前端初始化為 0。</td><td class="code">AC[0] &larr; 0</td></tr><tr><th class="scene_desc" colspan="3">計算序列的累積和</th></tr><tr><td class="symbol"><img src="formula_i.svg" /></td><td>與前 1 個元素累加。</td><td class="code">AC[i] &larr; AC[i-1] + A[i]</td></tr><tr><th class="scene_desc" colspan="3">針對指定區間計算區間和</th></tr><tr><td class="symbol"><img src="formula_write.svg" /></td><td>根據區間的起點和終點計算總和。</td><td class="code">sum &larr; AC[r] - AC[l-1]</td></tr><tr><td class="symbol"><img src="formula_segment.svg" /></td><td>指定區間。</td><td class="code">區間[l, r]</td></tr><tr><td class="symbol"><img src="formula_lp.svg" /></td><td>區間起點</td><td class="code">l</td></tr><tr><td class="symbol"><img src="formula_rp.svg" /></td><td>區間終點。</td><td class="code">r</td></tr>';
document.getElementById('scheme').innerHTML = '<tr><td style="text-align:center;width:100"><img src="anim_qr.svg" width="80"/></td><td class="frame"><hr class="separator"/><img height="160" class="frame_svg" src="scheme_step1.svg" /><p class="caption">逐一累加前面的元素，以求出累積和。</p><hr class="separator"/><img height="160" class="frame_svg" src="scheme_step2.svg" /><p class="caption">針對指定區間計算區間和。</p></td></tr>';
document.getElementById('scene').innerHTML = '<div><p><b class="scene_desc">輸入</b><br/><img src="scene_0.svg" alt="累積和 | 輸入" title="累積和 | 輸入"/></p></div><div><p><b class="scene_desc">計算序列的累積和</b><br/><img src="scene_1.svg" alt="累積和 | 計算序列的累積和" title="累積和 | 計算序列的累積和"/></p></div><div><p><b class="scene_desc">針對指定區間計算區間和</b><br/><img src="scene_2.svg" alt="累積和 | 針對指定區間計算區間和" title="累積和 | 針對指定區間計算區間和"/></p></div>';
document.getElementById('complexity').innerHTML = '<img src="../../../icons/complexity/linear.svg" />';
document.getElementById('prerequisites').innerHTML = '';
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);};
window.onload = function () {
document.getElementById('io_arrow').innerHTML = "&rarr;";
document.getElementById('level').innerHTML = "&#9733; &#9733; &#9733; ";
document.getElementById('ptitle').innerHTML = "點的凸包";
document.getElementById('ptitle_en').innerHTML = "Convex Hull";
document.getElementById('input_comment').innerHTML = "平面上的點群<ul><li>點數 N &le; 100,000</li></ul>";
document.getElementById('output_comment').innerHTML = "包含所有點且面積最小的凸多邊形";
document.getElementById('motivation').innerHTML = "從一個規模較大的點集合，求出其凸包。";
document.getElementById('description').innerHTML = "從一個點集合，求出凸包。";
document.getElementById('input_panel').innerHTML = '<img src="../../problems/convex_hull/input.svg" width="340"/>';
document.getElementById('output_panel').innerHTML = '<img src="../../problems/convex_hull/output.svg" width="340"/>';
document.getElementById('algorithm_icon').innerHTML = '<img src="../../icons/algorithms/andrew.svg" width="100"/>';
document.getElementById('atitle').innerHTML = "安德魯演算法 ";
document.getElementById('atitle_en').innerHTML = "Andrew's Algorithm";
document.getElementById('abstract').innerHTML = "安德魯演算法會分別建立凸包的上半部與下半部，以完成整個凸包。並利用堆疊的特性，以順時針方向逐步決定凸包邊上的點。";
document.getElementById('explanation').innerHTML = "　本節講解的是求凸包上半部的演算法。首先將所有的點按 x 座標的大小以升冪排序，若同時有多點符合此條件，則以 y 座標為準，同樣由小而大排序。接著將排序後的最初2 點新增到凸包中，並依序將此 2 點放入堆疊裡。<br></br>　安德魯演算法建立凸包的方式，是將各點視為加入凸包的候選點並逐一放入堆疊中，最後篩選完仍留在堆疊中的點，即為構成凸包的點。凸包的候選點會以一開始的排序結果依序進行篩選。假設目前檢視的點為 head。在決定是否要將 head 新增到凸包前，必須先調查 head 與堆疊頂端數來的第 2 個點 top2 及第 1 個點 top 之間的位置關係。若 head 的位置在 top2 → top 的逆時針方向，則將 top 從堆疊中刪除。反之，若 head 位於順時針方向，也就是可以形成凸包，則將 head 放入堆疊並新增到凸包中。<br/><br/>　凸包的下半部可使用同樣的步驟建立。不過在建立下半部時，各點需先按照 x 座標的大小以降冪排序，再使用與上半部同樣的演算法，從最右邊的點開始掃描，利用線條走向是否為順時針來判斷能否形成凸包。";
document.getElementById('note').innerHTML = "　由於安德魯演算法在選擇加入凸包的點時，每個點頂多只會被插入堆疊 2 次，因此這部分的時間複雜度為 O(N)。但其實瓶頸是在於一開始對所有點進行排序的部分，因此整體的時間複雜度取決於排序演算法，為 O(N log N)。";
document.getElementById('application').innerHTML = "";
document.getElementById('structure').innerHTML = '<tr><td style="text-align:center;width:100"><img src="../../icons/structures/P2D.svg" /><br/><br/></td><td class="frame">&nbsp;<img height="160" class="frame_svg" valign="middle" src="space_p2d.svg" />&nbsp;</td></tr><tr><td></td><td class="caption">點集合</td></tr>';
document.getElementById('variable').innerHTML = '<tr><th class="scene_desc" colspan="3">データ</th></tr>';
document.getElementById('formula').innerHTML = '<tr><th class="scene_desc" colspan="3">將各點排序</th></tr><tr><td class="symbol"><img src="formula_all.svg" /></td><td>將各點按 x 的大小以升冪方式排序。</td><td class="code"></td></tr><tr><th class="scene_desc" colspan="3">建立凸包</th></tr><tr><td class="symbol"><img src="formula_select.svg" /></td><td>檢查 3 個點的走向是否為順時針。</td><td class="code"></td></tr><tr><td class="symbol"><img src="formula_head.svg" /></td><td>將點的編號新增到堆疊當中。</td><td class="code">st.push(head)</td></tr><tr><td class="symbol"><img src="formula_trace.svg" /></td><td>逐步決定凸包的點。</td><td class="code"></td></tr>';
document.getElementById('scheme').innerHTML = '<tr><td style="text-align:center;width:100"><img src="anim_qr.svg" width="80"/></td><td class="frame"><hr class="separator"/><img height="160" class="frame_svg" src="scheme_step1.svg" /><p class="caption">確認點與點之間的位置關係。</p><hr class="separator"/><img height="160" class="frame_svg" src="scheme_step2.svg" /><p class="caption">將點從凸包的候選點中排除。</p><hr class="separator"/><img height="160" class="frame_svg" src="scheme_step3.svg" /><p class="caption">將點新增至凸包的候選點中。</p></td></tr>';
document.getElementById('scene').innerHTML = '<div><p><b class="scene_desc">將各點排序</b><br/><img src="scene_0.svg" alt="安德魯演算法  | 將各點排序" title="安德魯演算法  | 將各點排序"/></p></div><div><p><b class="scene_desc">建立凸包</b><br/><img src="scene_1.svg" alt="安德魯演算法  | 建立凸包" title="安德魯演算法  | 建立凸包"/></p></div>';
document.getElementById('complexity').innerHTML = '<img src="../../../icons/complexity/linear_log.svg" />';
document.getElementById('prerequisites').innerHTML = '<img src="../../icons/algorithms/stack_simulation.svg" width="60"/><img src="../../icons/algorithms/quick_sort.svg" width="60"/>';
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);};
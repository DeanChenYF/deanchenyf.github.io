window.onload = function () {
document.getElementById('io_arrow').innerHTML = "&rarr;";
document.getElementById('level').innerHTML = "&#9733; ";
document.getElementById('ptitle').innerHTML = "從序列中搜尋目標值";
document.getElementById('ptitle_en').innerHTML = "Search from Sequence";
document.getElementById('input_comment').innerHTML = "序列與目標值 ( 藍色長條 )<ul><li>元素數N &le; 1,000,000</li></ul>";
document.getElementById('output_comment').innerHTML = "目標值第 1 次出現的位置";
document.getElementById('motivation').innerHTML = "搜尋的意思是從有順序性的資料中找出特定的資料。搜尋演算法為資訊處理的基本，在許多應用程式中都會用到。";
document.getElementById('description').innerHTML = "請在陣列中尋找指定值。若指定值不存在，請傳回不存在；若存在，請傳回其最先出現的位置。";
document.getElementById('input_panel').innerHTML = '<img src="../../problems/search/input.svg" width="340"/>';
document.getElementById('output_panel').innerHTML = '<img src="../../problems/search/output.svg" width="340"/>';
document.getElementById('algorithm_icon').innerHTML = '<img src="../../icons/algorithms/linear_search.svg" width="100"/>';
document.getElementById('atitle').innerHTML = "線性搜尋法";
document.getElementById('atitle_en').innerHTML = "Linear Search";
document.getElementById('abstract').innerHTML = "從陣列最前端的元素開始，依序比較每一個元素是否與目標值相等。";
document.getElementById('explanation').innerHTML = "線性搜尋法會從陣列最前端的元素開始依序比較各元素，待找到與目標值相同的值或所有元素都檢查過後便結束。找到與目標值相同的值時，傳回其位置並結束。若所有元素都檢查過，仍未找到與目標值相同的值，則判斷陣列中不存在該值。";
document.getElementById('note').innerHTML = "若目標值不在陣列中，則所有元素都會被檢查到一次。這表示線性搜尋法的時間複雜度為 O(N)。對於單一查詢來說，這樣的時間複雜度是實用的，但若搜尋必須進行 Q 次，時間複雜度就會變成 O(QN)，因此線性搜尋法在需要進行多次查詢時，會被視為效率較差的演算法。";
document.getElementById('application').innerHTML = "線性搜尋法對於要進行搜尋的陣列元素，沒有任何排列方式的限制。雖然計算效率不高，但適用各種類型的資料序列。";
document.getElementById('structure').innerHTML = '<tr><td style="text-align:center;width:100"><img src="../../icons/structures/A1D.svg" /><br/><br/><img src="../../icons/structures/A0D.svg" /><br/><br/></td><td class="frame">&nbsp;<img height="160" class="frame_svg" valign="middle" src="space_st.svg" />&nbsp;</td></tr><tr><td></td><td class="caption">一維陣列與單節點</td></tr>';
document.getElementById('variable').innerHTML = '<tr><th class="scene_desc" colspan="3">データ</th></tr><tr><td class="symbol"><img src="variable_A.svg" /></td><td>要進行搜尋的序列</td><td class="code">A</td></tr><tr><td class="symbol"><img src="variable_key.svg" /></td><td>目標值</td><td class="code">key</td></tr>';
document.getElementById('formula').innerHTML = '<tr><th class="scene_desc" colspan="3">輸入</th></tr><tr><td class="symbol"><img src="formula_in.svg" /></td><td>載入要進行搜尋的序列。</td><td class="code"></td></tr><tr><td class="symbol"><img src="formula_ink.svg" /></td><td>載入目標值。</td><td class="code"></td></tr><tr><th class="scene_desc" colspan="3">搜尋</th></tr><tr><td class="symbol"><img src="formula_comp.svg" /></td><td>比較是否與目標值相同。</td><td class="code">if A[i] = key:</td></tr><tr><td class="symbol"><img src="formula_cp.svg" /></td><td>傳回第 1 個與目標值相同的元素位置。</td><td class="code">i</td></tr><tr><td class="symbol"><img src="formula_finished.svg" /></td><td>移到下一個元素。</td><td class="code">for 迴圈的 i 值 +1</td></tr>';
document.getElementById('scheme').innerHTML = '<tr><td style="text-align:center;width:100"><img src="anim_qr.svg" width="80"/></td><td class="frame"><hr class="separator"/><img height="160" class="frame_svg" src="scheme_step1.svg" /><p class="caption">比較目前位置的值與目標值。</p><hr class="separator"/><img height="160" class="frame_svg" src="scheme_step2.svg" /><p class="caption">傳回第 1 個與目標值相同的元素位置。</p></td></tr>';
document.getElementById('scene').innerHTML = '<div><p><b class="scene_desc">輸入</b><br/><img src="scene_0.svg" alt="線性搜尋法 | 輸入" title="線性搜尋法 | 輸入"/></p></div><div><p><b class="scene_desc">搜尋</b><br/><img src="scene_1.svg" alt="線性搜尋法 | 搜尋" title="線性搜尋法 | 搜尋"/></p></div>';
document.getElementById('complexity').innerHTML = '<img src="../../../icons/complexity/linear.svg" />';
document.getElementById('prerequisites').innerHTML = '';
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);};
window.onload = function () {
document.getElementById('io_arrow').innerHTML = "&rarr;";
document.getElementById('level').innerHTML = "&#9733; &#9733; &#9734; ";
document.getElementById('ptitle').innerHTML = "最小生成樹";
document.getElementById('ptitle_en').innerHTML = "Minimum Spanning Tree";
document.getElementById('input_comment').innerHTML = "加權無向圖<ul><li>節點數 N  &le; 1,000</li><li>邊數 　M &le; 10,000</li></ul>";
document.getElementById('output_comment').innerHTML = "最小生成樹(MST)";
document.getElementById('motivation').innerHTML = "　藉由挑選（刪除）連通圖的邊所獲得的連通樹，稱為生成樹（Spanning Tree）。生成樹可以利用深度優先搜尋或廣度優先搜尋等基本的追蹤演算法來獲得，但邊的選擇方式不同，得到的性質也會不同。";
document.getElementById('description').innerHTML = "請在加權無向圖中找出最小生成樹。最小生成樹是在所有可由圖形獲得的生成樹中，每條邊的權重總和最小者。";
document.getElementById('input_panel').innerHTML = '<img src="../../problems/minimum_spanning_tree_small/input.svg" width="340"/>';
document.getElementById('output_panel').innerHTML = '<img src="../../problems/minimum_spanning_tree_small/output.svg" width="340"/>';
document.getElementById('algorithm_icon').innerHTML = '<img src="../../icons/algorithms/prim_n2.svg" width="100"/>';
document.getElementById('atitle').innerHTML = "普林演算法";
document.getElementById('atitle_en').innerHTML = "Prim's Algorithm";
document.getElementById('abstract').innerHTML = "普林演算法（Prim's Algorithm）會從空的生成樹 T 開始，一次挑選一條最適合的邊，新增到該樹中，以逐步建立出最小生成樹。";
document.getElementById('explanation').innerHTML = "　在普林演算法（Prim's Algorithm）中，生成樹 T 是由適當的節點開始逐步擴展而成。擴展的每一個步驟，都會從連接 T 內節點與 T 外節點的邊，選擇一條權重最小的邊，並將此邊在 T 外的端點新增至 T 內。為了提升此處理的執行效率，本節使用了變數dist。dist[i] 會記錄連接節點 i 與 T 內節點的最小邊權重。換句話說，各個步驟其實就是在尋找 dist 最小的節點，並將找到的節點 u 新增至 T 內。而在尋找最小 dist 之前，若發現與 u 相鄰的節點 v 當下的 dist[v] 大於 weight[u][v]，則需先將 dist[v] 更新為較小值。普林演算法會在所有節點都包含在生成樹內時結束。<br><br>只要將各節點 v 在最小生成樹中的父節點記錄在 parent[v] 當中，即可利用 parent建立出最小生成樹。父節點的資訊可在更新 dist[v] 的同時，記錄在 parent[v] 中。除了根節點之外的所有節點 v 的邊 (v, parent[v]) 皆為最小生成樹的邊。";
document.getElementById('note').innerHTML = "　普林演算法（Prim's Algorithm）的最小生成樹 T 是以一個步驟新增 1 個節點的方式逐步擴展而成。若尋找權重最小節點的處理是以線性搜尋法執行，則時間複雜度將會是O(N<sup>2</sup>)。這一點無論圖形是以相鄰矩陣或相鄰串列實作，皆不會改變。<br><br>不過若是以堆積（優先佇列）管理最小權重，並從堆積中選擇最佳節點，且圖形是以相鄰串列實作，則普林演算法的時間複雜度將為 O((N+M)log N)。利用堆積（或優先佇列）進行的實作方式會在後續介紹求取最短路徑的戴克斯特拉演算法（Dijkstra's Algorithm）時講解。。";
document.getElementById('application').innerHTML = "許多領域中都有最小生成樹問題，如電腦的網路設計及電路配線等。而除了尋找最小生成樹外，最小生成樹本身也是解決各種圖形問題的一種有效特徵。這類問題存在各個不同的領域中，例如影像處理及生物科技（biotechnology）等。";
document.getElementById('structure').innerHTML = '<tr><td style="text-align:center;width:100"><img src="../../icons/structures/GR.svg" /><br/><br/></td><td class="frame">&nbsp;<img height="160" class="frame_svg" valign="middle" src="space_st.svg" />&nbsp;</td></tr><tr><td></td><td class="caption">加權無向圖</td></tr>';
document.getElementById('variable').innerHTML = '<tr><th class="scene_desc" colspan="3">データ</th></tr><tr><td class="symbol"><img src="variable_dist.svg" /></td><td>連到 T 內節點的最小邊上的權重</td><td class="code">dist</td></tr><tr><td class="symbol"><img src="variable_parent.svg" /></td><td>最小生成樹中的父節點</td><td class="code">parent</td></tr><tr><td class="symbol"><img src="variable_weight.svg" /></td><td>節點間的距離</td><td class="code">weight</td></tr>';
document.getElementById('formula').innerHTML = '<tr><th class="scene_desc" colspan="3">決定起點與初始化</th></tr><tr><td class="symbol"><img src="formula_source.svg" /></td><td>選擇適當起點並將其 dist 初始化為 0。</td><td class="code"></td></tr><tr><td class="symbol"><img src="formula_others.svg" /></td><td>將其餘節點的 dist 初始化為極大的值。</td><td class="code"></td></tr><tr><th class="scene_desc" colspan="3">建立最小生成樹</th></tr><tr><td class="symbol"><img src="formula_select.svg" /></td><td>尋找 dist 最小的節點。</td><td class="code"># find minimum</td></tr><tr><td class="symbol"><img src="formula_u.svg" /></td><td>指向擁有最小權重的節點。</td><td class="code">u</td></tr><tr><td class="symbol"><img src="formula_v.svg" /></td><td>更新節點的 dist 與 parent。</td><td class="code">dist[v] &larr; weight[u][v]<br>parent[v] &larr; u</td></tr><tr><td class="symbol"><img src="formula_edges.svg" /></td><td>標示最小生成樹暫定要使用的邊。</td><td class="code">(v, parent[v])</td></tr><tr><td class="symbol"><img src="formula_finished.svg" /></td><td>擴大最小生成樹。</td><td class="code">將 u 新增至 T 內</td></tr><tr><th class="scene_desc" colspan="3">輸出最小生成樹</th></tr><tr><td class="symbol"><img src="formula_all.svg" /></td><td>利用父節點的資訊建立最小生成樹。</td><td class="code"></td></tr>';
document.getElementById('scheme').innerHTML = '<tr><td style="text-align:center;width:100"><img src="anim_qr.svg" width="80"/></td><td class="frame"><hr class="separator"/><img height="160" class="frame_svg" src="scheme_step1.svg" /><p class="caption">尋找擁有最小 dist 的節點。</p><hr class="separator"/><img height="160" class="frame_svg" src="scheme_step2.svg" /><p class="caption">將所選節點新增到 T 內，並更新相鄰節點的 dist。</p></td></tr>';
document.getElementById('scene').innerHTML = '<div><p><b class="scene_desc">決定起點與初始化</b><br/><img src="scene_0.svg" alt="普林演算法 | 決定起點與初始化" title="普林演算法 | 決定起點與初始化"/></p></div><div><p><b class="scene_desc">建立最小生成樹</b><br/><img src="scene_1.svg" alt="普林演算法 | 建立最小生成樹" title="普林演算法 | 建立最小生成樹"/></p></div><div><p><b class="scene_desc">輸出最小生成樹</b><br/><img src="scene_2.svg" alt="普林演算法 | 輸出最小生成樹" title="普林演算法 | 輸出最小生成樹"/></p></div>';
document.getElementById('complexity').innerHTML = '<img src="../../../icons/complexity/quad.svg" /><img src="../../../icons/complexity/linear_log.svg" />';
document.getElementById('prerequisites').innerHTML = '';
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);};
class Heap:

    buildHeap():
        for i &larr; heapSize/2 - 1 downto 0:
            downHeapLoop(i)

    insert(x):
        increase(heapSize, x)

    insert(x, v):
        increase(heapSize, x, v)
        heapSize++

    increase(i, x):
        key[i] &larr; x
  
    increase(i, x, v):
        key[i] &larr; x
        val[i] &larr; v

    decrease(p, x):
        key[p] &larr; x

    swapElement(u, v):
        swap(key[u], key[v])
        swap(val[u], val[v])

    copyElement(from, to):
        if  from = to return
        key[to] &larr; key[from]
        val[to] &larr; val[from]

    top()
        return key[0]
  
    topVal():
        return val[0]

    topPair():
        return (key[0], val[0])

    upHeap(i)
    while True:
      if  i &le; 0  break
      if  key[parent(i)] &ge; key[i] break
      swap(key[i], key[parent(i)])
      swap(val[i], val[parent(i)])
      i &larr; parent(i)

    downHeap(i):
        _downHeap(i)
  
    _downHeap(i):
        l &larr; left(i)
        r &larr; right(i)

        if l &lt; heapSize and key[l] &gt; key[i]: largest &larr; l
        else largest &larr; i
    
        if r &gt; heapSize nad key[r] &gt; key[largest]: largest &larr; r

        if largest != i:
             swap(key[i], key[largest])
             swap(val[i], val[largest])
             _downHeap(largest)

    upHeapLoop(i):
        kt = key[i]
        vt = val[i]
        while True:
            if i &le; 0: break
            p &larr; parent(i)
            if key[parent(i)] &ge; kt: break;
            key[i] &larr; key[parent(i)]
            val[i] &larr; val[parent(i)]
            i &larr; parent(i)
        key[i] &larr; kt
        val[i] &larr; vt

    downHeapLoop(i):
        largest &larr; i
        cur &larr; i;
        kt &larr; key[i]
        vt &larr; val[i]
        while True:
            if left(cur) &lt; heapSize and right(cur) &lt; heapSize:
                if key[left(cur)] &gt; key[right(cur)]: largest &larr; left(cur)
                else: largest &lar;; right(cur)
            elif left(cur) &lt; heapSize:
                largest &larr; left(cur)
            elif right(cur) &lt; heapSize:
                largest &larr; right(cur)
            else:
                largest &larr; -1

            if largest = -1: break
            if key[largest] &le; kt: break
      
            key[cur] &larr; key[largest]
            val[cur] &larr; val[largest]
            cur &larr; largest
        key[cur] &larr; kt
        val[cur] &larr; vt

    empty():
        return heapSize = 0

    parent(i):
        return (i-1)/2

    left(i):
        return 2*i+1

    right(i):
        return 2*i+2

window.onload = function () {
document.getElementById('io_arrow').innerHTML = "&rarr;";
document.getElementById('level').innerHTML = "&#9733; &#9733; &#9733; &#9733; &#9734; ";
document.getElementById('ptitle').innerHTML = "整列された辞書";
document.getElementById('ptitle_en').innerHTML = "Sorted Dictionary";
document.getElementById('input_comment').innerHTML = "整列された辞書に対する検索・追加・削除操作<ul><li>操作・問い合わせの数Q &le; 100,000</li><li>0 &le; キー &le; 1,000,000,000</li></ul>";
document.getElementById('output_comment').innerHTML = "問い合わせへの回答と整列された要素の出力";
document.getElementById('motivation').innerHTML = "辞書の内容を常に整列して管理しておくことで、より柔軟に、様々な問い合わせに答えることができるようになります。";
document.getElementById('description').innerHTML = "データの検索・追加・削除に加え、整列済みの要素の管理・提供を行う、辞書のデータ構造を実装してください。ここでは、キーと値をまとめ、データの実態としてキーのみを扱うものとします。";
document.getElementById('input_panel').innerHTML = '<img src="../../problems/sorted_dictionary/input.svg" width="340"/>';
document.getElementById('output_panel').innerHTML = '<img src="../../problems/sorted_dictionary/output.svg" width="340"/>';
document.getElementById('algorithm_icon').innerHTML = '<img src="../../icons/algorithms/bst_simulation.svg" width="100"/>';
document.getElementById('atitle').innerHTML = "二分探索木";
document.getElementById('atitle_en').innerHTML = "Binary Search Tree";
document.getElementById('abstract').innerHTML = "二分探索木は、各ノードにキーを持ち、次に示す「二分探索木条件」を常に満たすような探索木です。：<br><br>xを二分探索木に属するノード、yをxの左部分木に属するノード、zをxの右部分木に属するノードとすると、yのキー &le; xのキー &le; zのキー<br/><br/>ここでは主に、二分探索木にキーを追加するためのアルゴリズムについて解説します。";
document.getElementById('explanation').innerHTML = "二分探索木へ新しいキーを追加する操作では、ノードを生成して二分探索木条件を満たすように正しい位置に挿入する必要があります。与えられたキーを含む新しいノードは、既存の二分探索木の葉のいずれかの子になります。追加するノードの位置は、根から探索を開始し、現在地のノードのキーと与えられたキーを比較し、与えられたキーの方が小さければ左部分木に降り、そうでなければ右部分木に降りていきます。葉に到達したとき（子がないとき）、ここでもキーの大小関係からどちらの子になるかを判断し、キーを設定したうえでノードを追加します。<br><br> この挿入アルゴリズムは、与えられたキーを探索する場合にも容易に応用することができます。<br><br>整列されたキーを維持する二分探索木の特長のひとつは、木に対して中間順巡回を行うと、キーの昇順でキーの列が得られることです。さらに、指定された要素の位置が特定できるため、操作の幅が広がります。また、最小値や最大値を求めることも容易です。";
document.getElementById('note').innerHTML = "二分探索木へ新しいキー（ノード）を追加するアルゴリズムの計算量は木の高さhに依存し、オーダーはO(h)となります。二分探索木内のノードの数をNとすれば、追加操作で与えられるキーの列に偏りがなければO(log N)になります。しかし、一般的には追加されるキーとそれらの順番によって、木のバランスは崩れていき、高さが高くなっていきます。最悪の場合はリスト構造のようになり、１回の追加・検索のオーダーがO(N)となってしまいます。";
document.getElementById('application').innerHTML = "二分探索木は、キーが整列された辞書を実装するために応用することができますが、木のバランスを考えない素朴な実装は実用的ではありません。また、二分探索木はその特性から、優先度付きキューとしても活用できますが、同様にバランスの良い木を維持する工夫が必要になります。";
document.getElementById('structure').innerHTML = '<tr><td style="text-align:center;width:100"><img src="../../icons/structures/DBT.svg" /><br/><br/></td><td class="frame">&nbsp;<img height="160" class="frame_svg" valign="middle" src="space_st.svg" />&nbsp;</td></tr><tr><td></td><td class="caption">動的な二分木</td></tr>';
document.getElementById('variable').innerHTML = '<tr><th class="scene_desc" colspan="3">データ</th></tr><tr><td class="symbol"><img src="variable_key.svg" /></td><td>辞書に格納するキー</td><td class="code">key</td></tr>';
document.getElementById('formula').innerHTML = '<tr><th class="scene_desc" colspan="3">データの検索・挿入</th></tr><tr><td class="symbol"><img src="formula_select.svg" /></td><td>現在地のキーと比較し、左に降りるか右に降りるか判断します。</td><td class="code">if data &lt; x.key:</td></tr><tr><td class="symbol"><img src="formula_selected.svg" /></td><td>選ばれた子を指します。</td><td class="code">x</td></tr><tr><td class="symbol"><img src="formula_write.svg" /></td><td>キーを設定したノードを生成し挿入します。</td><td class="code">insert(data):の後半</td></tr><tr><th class="scene_desc" colspan="3">キーの出力</th></tr><tr><td class="symbol"><img src="formula_output.svg" /></td><td>中間順巡回でキーを順番に出力します。</td><td class="code">inorder(u):</td></tr>';
document.getElementById('scheme').innerHTML = '<tr><td style="text-align:center;width:100"><img src="anim_qr.svg" width="80"/></td><td class="frame"><hr class="separator"/><img height="160" class="frame_svg" src="scheme_step1.svg" /><p class="caption">追加するキーの挿入場所を探索します。</p><hr class="separator"/><img height="160" class="frame_svg" src="scheme_step2.svg" /><p class="caption">探索を終了し、キーを設定したノードを挿入します。</p></td></tr>';
document.getElementById('scene').innerHTML = '<div><p><b class="scene_desc">データの検索・挿入</b><br/><img src="scene_0.svg" alt="二分探索木 | データの検索・挿入" title="二分探索木 | データの検索・挿入"/></p></div><div><p><b class="scene_desc">キーの出力</b><br/><img src="scene_1.svg" alt="二分探索木 | キーの出力" title="二分探索木 | キーの出力"/></p></div>';
document.getElementById('complexity').innerHTML = '<img src="../../../icons/complexity/linear.svg" />';
document.getElementById('prerequisites').innerHTML = '<img src="../../icons/algorithms/btree_inorder.svg" width="60"/>';
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);};
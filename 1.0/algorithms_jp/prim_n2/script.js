window.onload = function () {
document.getElementById('io_arrow').innerHTML = "&rarr;";
document.getElementById('level').innerHTML = "&#9733; &#9733; &#9734; ";
document.getElementById('ptitle').innerHTML = "最小全域木";
document.getElementById('ptitle_en').innerHTML = "Minimum Spanning Tree";
document.getElementById('input_comment').innerHTML = "重み付き無向グラフ<ul><li>ノードの数N &le; 1,000</li><li>エッジの数M &le; 10,000</li></ul>";
document.getElementById('output_comment').innerHTML = "最小全域木";
document.getElementById('motivation').innerHTML = "連結なグラフからエッジを選択して（削除して）得られる連結な木を全域木(Spanning Tree)と呼びます。全域木は深さ優先探索や幅優先探索などの基本的な巡回アルゴリズムで得られますが、エッジの選び方によって様々な性質を得ることができます。";
document.getElementById('description').innerHTML = "重み付き無向グラフの最小全域木を求めてください。最小全域木とは、グラフから生成できる全域木のうち、エッジの重みの総和が最も小さいものです。";
document.getElementById('input_panel').innerHTML = '<img src="../../problems/minimum_spanning_tree_small/input.svg" width="340"/>';
document.getElementById('output_panel').innerHTML = '<img src="../../problems/minimum_spanning_tree_small/output.svg" width="340"/>';
document.getElementById('algorithm_icon').innerHTML = '<img src="../../icons/algorithms/prim_n2.svg" width="100"/>';
document.getElementById('atitle').innerHTML = "プリムのアルゴリズム";
document.getElementById('atitle_en').innerHTML = "Prim's Algorithm";
document.getElementById('abstract').innerHTML = "プリムのアルゴリズムは、空の全域木Tから開始し、この全域木Tに最適なエッジを１つずつ選んで追加していき、最終的に最小全域木を構築します。";
document.getElementById('explanation').innerHTML = "プリムのアルゴリズムでは、適当なノードを起点として全域木Tを拡張していきます。各ステップで、Tに含まれるノードとTに含まれないノードを繋ぐエッジの中で、重みが最も小さいものを選び、その端点であるTに含まれないノードをTに含めていきます。この処理を効率良く行うために、変数distを用います。各ノードiについて、自身とTの中のノードを繋ぐエッジの中で重みが最小のものの重みをdist[i]に記録していきます。つまり、各ステップでdistが最小のノードを探し、得られたノードuをTに含めます。このとき、uに隣接するノードvのdist[v]よりもweight[u][v]の方が小さければdist[v]を更新します。プリムのアルゴリズムは、全てのノードが全域木に含まれた時点で終了します。<br><br>各ノードvについて、最小全域木における親parent[v]を記録しておけば、parentから最小全域木を構築することができます。親の情報は、dist[v]が更新されるタイミングで、parent[v]にuを記録します。根以外のvについてエッジ(v, parent[v])が最小全域木に含まれるエッジになります。";
document.getElementById('note').innerHTML = "プリムのアルゴリズムは、各ステップでノードを１つ追加しながら最小全域木Tを拡張していきます。重みが最小のノードを探す処理を線形探索で行う場合は、オーダーはO($N^2$)となります。これは、隣接行列、隣接リストで実装しても同じです。一方、最小の重みをヒープ（優先度付きキュー）で管理し、最適なノードをヒープから選択するようにし、グラフを隣接リストで実装した場合は、プリムのアルゴリズムのオーダーはO( (N + M) log N)となります。ヒープ（または優先度付きキュー）による実装は、最短経路を求めるダイクストラのアルゴリズムのトピックで解説します。";
document.getElementById('application').innerHTML = "最小全域木問題は、コンピュータの分野ではネットワークの設計や回路の配線など、様々な分野に現れます。最小全域木は、その問題そのものではなくとも、グラフに関する様々な問題を解決するための有効な特徴となります。このような問題の分野は、効率的な解法が存在しないグラフの巡回問題、画像処理、バイオ工学など多岐に渡ります。";
document.getElementById('structure').innerHTML = '<tr><td style="text-align:center;width:100"><img src="../../icons/structures/GR.svg" /><br/><br/></td><td class="frame">&nbsp;<img height="160" class="frame_svg" valign="middle" src="space_st.svg" />&nbsp;</td></tr><tr><td></td><td class="caption">重み付き無向グラフ</td></tr>';
document.getElementById('variable').innerHTML = '<tr><th class="scene_desc" colspan="3">データ</th></tr><tr><td class="symbol"><img src="variable_dist.svg" /></td><td>Tに含まれるノードへ向かうエッジの重みの最小値</td><td class="code">dist</td></tr><tr><td class="symbol"><img src="variable_parent.svg" /></td><td>最小全域木における親</td><td class="code">parent</td></tr><tr><td class="symbol"><img src="variable_weight.svg" /></td><td>ノード間の距離</td><td class="code">weight</td></tr>';
document.getElementById('formula').innerHTML = '<tr><th class="scene_desc" colspan="3">始点の決定と初期化</th></tr><tr><td class="symbol"><img src="formula_source.svg" /></td><td>適当な始点のdistを0に初期化します。</td><td class="code"></td></tr><tr><td class="symbol"><img src="formula_others.svg" /></td><td>他のノードのdistを大きな値で初期化します。</td><td class="code"></td></tr><tr><th class="scene_desc" colspan="3">最小全域木の構築</th></tr><tr><td class="symbol"><img src="formula_select.svg" /></td><td>distが最小のノードを探します。</td><td class="code"># find minimum</td></tr><tr><td class="symbol"><img src="formula_u.svg" /></td><td>distが最小のノードを指します。</td><td class="code">u</td></tr><tr><td class="symbol"><img src="formula_v.svg" /></td><td>ノードのdistとparentを更新します。</td><td class="code">dist[v] &larr; weight[u][v]<br>parent[v] &larr; u</td></tr><tr><td class="symbol"><img src="formula_edges.svg" /></td><td>最小全域木の暫定エッジを表します。</td><td class="code">(v, parent[v])</td></tr><tr><td class="symbol"><img src="formula_finished.svg" /></td><td>最小全域木を拡張していきます。</td><td class="code">Tにuを含める</td></tr><tr><th class="scene_desc" colspan="3">最小全域木を出力</th></tr><tr><td class="symbol"><img src="formula_all.svg" /></td><td>親の情報から最小全域木を構築します。</td><td class="code"></td></tr>';
document.getElementById('scheme').innerHTML = '<tr><td style="text-align:center;width:100"><img src="anim_qr.svg" width="80"/></td><td class="frame"><hr class="separator"/><img height="160" class="frame_svg" src="scheme_step1.svg" /><p class="caption">最小のdistをもつノードを探します。</p><hr class="separator"/><img height="160" class="frame_svg" src="scheme_step2.svg" /><p class="caption">選んだノードをTに追加し、隣接するノードのdistを更新します。</p></td></tr>';
document.getElementById('scene').innerHTML = '<div><p><b class="scene_desc">始点の決定と初期化</b><br/><img src="scene_0.svg" alt="プリムのアルゴリズム | 始点の決定と初期化" title="プリムのアルゴリズム | 始点の決定と初期化"/></p></div><div><p><b class="scene_desc">最小全域木の構築</b><br/><img src="scene_1.svg" alt="プリムのアルゴリズム | 最小全域木の構築" title="プリムのアルゴリズム | 最小全域木の構築"/></p></div><div><p><b class="scene_desc">最小全域木を出力</b><br/><img src="scene_2.svg" alt="プリムのアルゴリズム | 最小全域木を出力" title="プリムのアルゴリズム | 最小全域木を出力"/></p></div>';
document.getElementById('complexity').innerHTML = '<img src="../../../icons/complexity/quad.svg" /><img src="../../../icons/complexity/linear_log.svg" />';
document.getElementById('prerequisites').innerHTML = '';
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);};
<pre>
class PriorityQueue:
    N          # 完全二分木のノード数
    A          # キューの要素を保持する配列
    heapSize   # 実際にデータを保持しているヒープサイズ

    insert(x):
        A[heapSize++] &larr; x
        upHeap(heapSize-1)

    top():
        return A[0]

    extract():
        val &larr; A[0]
        A[0] &larr; A[heapSize-1]
        heapSize--
        downHeap(0)
        return val

    upHeap(i): # 挿入ベースの実装
        val &larr; A[i]

        while True:
            if  i &le; 0: break
            if A[parent(i)] &ge; val: break
            A[i] &larr; A[parent(i)]
            i &larr; parent(i)
        
        A[i] &larr; val

    downHeap(i): # 挿入ベースの実装
        largest &larr; i
        val = A[i]

        while True:
            if left(i) < heapSize and right(i) < heapSize:
                if A[left(i)] > A[right(i)] ):
                    largest &larr; left(i)
                else:
                    largest &larr; right(i)
            else if left(i) < heapSize:
                largest &larr; left(i)
            else if right(i) < heapSize:
                largest &larr; right(i)
            else:
                largest &larr; NIL

            if largest = NIL : break
            if A[largest] &le; val: break
      
            A[i] &larr; A[largest]
            i &larr; largest

        A[i] &larr; val
</pre>


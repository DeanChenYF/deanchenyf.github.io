<pre>
# Segment Tree for RSM
class RSQ:
    N   # 完全二分木のノード数
    n   # 列の要素数 = 葉の数
    sum # 和を保持する配列

    # 最低限必要な列の要素数で初期化
    init(len):
        n &larr; 1
        while n < len:
            n &larr; n*2  # 葉の数nを2のべき乗にする
        N &larr; 2*n - 1  # 完全二分木のノード数を調整する 
        for i &larr; 0 to N-1:
            sum[i] &larr; 0

    findSum(a, b):
        return query(a, b, 0, 0, n)

    query(a, b, k, l, r):
        if r &le; a or b &le; l:
            res &larr; 0
        else if a &le; l and r &le; b:
            res &larr; sum[k]
        else:
            vl &larr; query(a, b, left(k), l, (l+r)/2)
            vr &larr; query(a, b, right(k), (l+r)/2, r)
            res &larr; vl + vr

        return res

    # k番目の要素にxを加算する
    update(k, x):
        k &larr; k + n - 1
        sum[k] &larr; sum[k] + x

        while  k &gt; 0:
            k &larr; parent(k)
            sum[k] &larr; sum[left(k)] + sum[right(k)]

    left(k):
        return 2*k + 1

    right(k):
        return 2*k + 2

    parent(k):
        return (k - 1)/2
</pre>

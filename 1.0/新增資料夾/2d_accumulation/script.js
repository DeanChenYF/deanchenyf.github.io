window.onload = function () {
document.getElementById('io_arrow').innerHTML = "&rarr;";
document.getElementById('level').innerHTML = "&#9733; &#9733; &#9733; ";
document.getElementById('ptitle').innerHTML = "重疊的矩形";
document.getElementById('ptitle_en').innerHTML = "Overlapped Rectangles";
document.getElementById('input_comment').innerHTML = "由左上角與右下角的一組座標表示重疊的矩形數量<ul><li>1 &le; x, y座標 &le; 1,000</li><li>矩形數 &le; 100,000</ul>";
document.getElementById('output_comment').innerHTML = "重疊處的矩形個數";
document.getElementById('motivation').innerHTML = "上一節利用一維累積和快速算出各 x 座標上重疊的線段數量，同樣的概念也可以應用在二維的問題上。";
document.getElementById('description').innerHTML = "從多個矩形求出各座標上重疊（1 個以上）的矩形數量。";
document.getElementById('input_panel').innerHTML = '<img src="../../problems/overlapping_2d/input.svg" width="340"/>';
document.getElementById('output_panel').innerHTML = '<img src="../../problems/overlapping_2d/output.svg" width="340"/>';
document.getElementById('algorithm_icon').innerHTML = '<img src="../../icons/algorithms/2d_accumulation.svg" width="100"/>';
document.getElementById('atitle').innerHTML = "二維累積和";
document.getElementById('atitle_en').innerHTML = "2 Dimensional Accumulation";
document.getElementById('abstract').innerHTML = "我們用二維陣列來存放矩形，矩形是用 x 與 y 座標來標示頂點位置，並將各座標 上的矩形數量記錄在對應的陣列元素中。 二維陣列結構的大小 N×M 必須分別大於 或等於 x 與 y 座標的最大值 +1，否則會放 不下。 當矩形新增到陣列後，利用累積和演算 法分別掃描陣列的水平及垂直方向，將各 元素的值加上其前 1 欄 ( 或前 1 列 ) 元素 的值，經過累加處理後，就能算出對應座 標值上重疊的矩形數量。";
document.getElementById('explanation').innerHTML = "本節將一維累積和的做法擴展到二維累積和上。當矩形放到二維陣列後，假設矩形的 左上角與右下角頂點座標分別為 (x1, y1) 與 (x2, y2)，則將 A[x1][y1] 與 A[x2][y2] 加 1 （表示增加 1 個矩形），將 A[x1][y2] 與 A[x2][y1] 減 1（表示減少 1 個矩形）。 請注意，矩形範圍不包含矩形的終點，例如座標（1,1）、（5,4）的矩形其框線只會畫到 座標（1,1）、（4,3）。<br/><br/>接著，累積和演算法會先掃描水平方向（沿著 x 值增長的方向），將各元素的值加上其 前 1 欄元素的值，再以同樣做法掃描垂直方向（沿著 y 值增長的方向），將各元素的值加 上其前 1 列元素的值。經過累加後，各元素的值就是對應座標值上重疊的矩形數量。";
document.getElementById('note').innerHTML = "此問題也可以用較單純的演算法解決，只要將陣列中對應到矩形的範圍都加 1（整塊 填滿）即可，這項操作的時間複雜度為 O(NM)。由於此操作需對每一塊矩形執行，因此 整體來說，此演算法的時間複雜度將為 O(QNM)。<br/><br/>至於利用累積和的方法，其複雜度由於新增 Q 個矩形時為 O(Q)，計算累積和時為  O(NM)，因此整體的時間複雜度為 O(Q+NM)。";
document.getElementById('application').innerHTML = "";
document.getElementById('structure').innerHTML = '<tr><td style="text-align:center;width:100"><img src="../../icons/structures/A2D.svg" /><br/><br/></td><td class="frame">&nbsp;<img height="160" class="frame_svg" valign="middle" src="space_st.svg" />&nbsp;</td></tr><tr><td></td><td class="caption">二維陣列</td></tr>';
document.getElementById('variable').innerHTML = '<tr><th class="scene_desc" colspan="3">資料</th></tr><tr><td class="symbol"><img src="variable_A.svg" /></td><td>矩形重疊的個數</td><td class="code">A</td></tr>';
document.getElementById('formula').innerHTML = '<tr><th class="scene_desc" colspan="3">新增矩形</th></tr><tr><td class="symbol"><img src="formula_add.svg" /></td><td>將對應於左上角及右下角的元素加 1。</td><td class="code">A[x1][y1]++<br/>A[x2][y2]++</td></tr><tr><td class="symbol"><img src="formula_sub.svg" /></td><td>將對應於左下角及右上角的元素減 1。</td><td class="code">A[x1][y2]--<br/>A[x2][y1]--</td></tr><tr><th class="scene_desc" colspan="3">掃描水平方向</th></tr><tr><td class="symbol"><img src="formula_scan.svg" /></td><td>加上前 1 欄的元素。</td><td class="code">A[x][y] &larr; A[x][y] + A[x-1][y]</td></tr><tr><th class="scene_desc" colspan="3">掃描垂直方向</th></tr><tr><td class="symbol"><img src="formula_scan.svg" /></td><td>加上前 1 列的元素。</td><td class="code">A[x][y] &larr; A[x][y] + A[x][y-1]</td></tr>';
document.getElementById('scheme').innerHTML = '<tr><td style="text-align:center;width:100"><img src="anim_qr.svg" width="80"/></td><td class="frame"><hr class="separator"/><img height="160" class="frame_svg" src="scheme_step1.svg" /><p class="caption">新增矩形。</p><hr class="separator"/><img height="160" class="frame_svg" src="scheme_step2.svg" /><p class="caption">計算水平與垂直方向的累積和。</p></td></tr>';
document.getElementById('scene').innerHTML = '<div><p><b class="scene_desc">新增矩形</b><br/><img src="scene_0.svg" alt="二維累積和 | 新增矩形" title="二維累積和 | 新增矩形"/></p></div><div><p><b class="scene_desc">掃描水平方向</b><br/><img src="scene_1.svg" alt="二維累積和 | 掃描水平方向" title="二維累積和 | 掃描水平方向"/></p></div><div><p><b class="scene_desc">掃描垂直方向</b><br/><img src="scene_2.svg" alt="二維累積和 | 掃描垂直方向" title="二維累積和 | 掃描垂直方向"/></p></div>';
document.getElementById('complexity').innerHTML = '<img src="../../../icons/complexity/quad.svg" />';
document.getElementById('prerequisites').innerHTML = '<img src="../../icons/algorithms/1d_accumulation.svg" width="60"/>';
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);};
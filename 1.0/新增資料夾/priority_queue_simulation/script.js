window.onload = function () {
document.getElementById('io_arrow').innerHTML = "&rarr;";
document.getElementById('level').innerHTML = "&#9733; &#9733; &#9734; ";
document.getElementById('ptitle').innerHTML = "高優先權資料先出";
document.getElementById('ptitle_en').innerHTML = "Dequeue by Priority";
document.getElementById('input_comment').innerHTML = "新增的資料<ul><li>操作次數Q &le; 100,000</li></ul>";
document.getElementById('output_comment').innerHTML = "根據優先權取出的資料";
document.getElementById('motivation').innerHTML = "許多演算法都需要持續新增資料，並從優先權最高者開始取出的資料結構。";
document.getElementById('description').innerHTML = "請實作一個會優先取出優先權最高的資料（本節以最大值為例）的資料結構。";
document.getElementById('input_panel').innerHTML = '<img src="../../problems/priority_queue/input.svg" width="340"/>';
document.getElementById('output_panel').innerHTML = '<img src="../../problems/priority_queue/output.svg" width="340"/>';
document.getElementById('algorithm_icon').innerHTML = '<img src="../../icons/algorithms/priority_queue_simulation.svg" width="100"/>';
document.getElementById('atitle').innerHTML = "優先佇列";
document.getElementById('atitle_en').innerHTML = "Priority Queue";
document.getElementById('abstract').innerHTML = "優先佇列是一種會優先取出優先權最高者的佇列。實作上可使用堆積結構來儲存資料，以便快速回應操作及查詢。由於優先佇列中的元素數會動態變化，因此除了大小為 N 的完整二元樹之外，還需要另外準備 1 個變數來記錄堆積中的元素數。";
document.getElementById('explanation').innerHTML = "元素在插入優先佇列時，會先新增到堆積尾端，再視情況以該位置為起點進行 Up Heap。相反地，資料在取出時，則是從堆積的根節點取出（刪除）。資料被取出後，必須將記錄堆積大小的變數減 1，並將堆積尾端的元素複製到空白的根節點，再從根節點進行 Down Heap，以重新調整為最大堆積。";
document.getElementById('note').innerHTML = "插入資料時會使用 Up Heap，因此對優先佇列執行插入的時間複雜度為 O(log N)。取出（刪除）資料時會用 Down Heap，因此取出資料的時間複雜度也同樣是 O(log N)。";
document.getElementById('application').innerHTML = "優先佇列被廣泛應用到需管理順序的應用程式當中，例如作業系統中的排程（process）處理等。此外，尋找最短路徑的 Dijkstra（戴克斯特拉）演算法等進階演算法，也是以優先佇列為其基礎資料結構。";
document.getElementById('structure').innerHTML = '<tr><td style="text-align:center;width:100"><img src="../../icons/structures/ACBT.svg" /><br/><br/></td><td class="frame">&nbsp;<img height="160" class="frame_svg" valign="middle" src="space_t.svg" />&nbsp;</td></tr><tr><td></td><td class="caption">完整二元樹</td></tr>';
document.getElementById('variable').innerHTML = '<tr><th class="scene_desc" colspan="3">資料</th></tr><tr><td class="symbol"><img src="variable_A.svg" /></td><td>佇列的元素</td><td class="code">A</td></tr>';
document.getElementById('formula').innerHTML = '<tr><th class="scene_desc" colspan="3">初始化</th></tr><tr><td class="symbol"><img src="formula_input.svg" /></td><td>調整整數序列，使其滿足堆積性質。</td><td class="code"></td></tr><tr><th class="scene_desc" colspan="3">插入與刪除資料</th></tr><tr><td class="symbol"><img src="formula_write.svg" /></td><td>插入元素。</td><td class="code">A[heapSize++] &larr; x</td></tr><tr><td class="symbol"><img src="formula_upRotation.svg" /></td><td>進行 Up Heap。</td><td class="code">upHeap(heapSize-1)</td></tr><tr><td class="symbol"><img src="formula_downRotation.svg" /></td><td>進行 Down Heap。</td><td class="code">downHeap(0)</td></tr><tr><td class="symbol"><img src="formula_heap.svg" /></td><td>記錄佇列中的元素數。</td><td class="code">區間[0, heapSize)</td></tr>';
document.getElementById('scheme').innerHTML = '<tr><td style="text-align:center;width:100"><img src="anim_qr.svg" width="80"/></td><td class="frame"><hr class="separator"/><img height="160" class="frame_svg" src="scheme_insert.svg" /><p class="caption">插入資料</p><hr class="separator"/><img height="160" class="frame_svg" src="scheme_extract.svg" /><p class="caption">取出並刪除優先權最高的資料。</p></td></tr>';
document.getElementById('scene').innerHTML = '<div><p><b class="scene_desc">初始化</b><br/><img src="scene_0.svg" alt="優先佇列 | 初始化" title="優先佇列 | 初始化"/></p></div><div><p><b class="scene_desc">插入與刪除資料</b><br/><img src="scene_1.svg" alt="優先佇列 | 插入與刪除資料" title="優先佇列 | 插入與刪除資料"/></p></div>';
document.getElementById('complexity').innerHTML = '<img src="../../../icons/complexity/log.svg" />';
document.getElementById('prerequisites').innerHTML = '<img src="../../icons/algorithms/upheap_simulation.svg" width="60"/><img src="../../icons/algorithms/downheap_simulation.svg" width="60"/><img src="../../icons/algorithms/queue_simulation.svg" width="60"/>';
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);};
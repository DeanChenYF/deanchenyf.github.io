window.onload = function () {
document.getElementById('io_arrow').innerHTML = "&rarr; <br/>&larr;";
document.getElementById('level').innerHTML = "&#9733; &#9734; ";
document.getElementById('ptitle').innerHTML = "後進先出（LIFO，";
document.getElementById('ptitle_en').innerHTML = "Last-In-First-Out)";
document.getElementById('input_comment').innerHTML = "新增資料";
document.getElementById('output_comment').innerHTML = "根據 LIFO 原則取出的資料";
document.getElementById('motivation').innerHTML = "許多演算法與系統控制在執行過程中，常常需要將未處理完的資料或狀態暫時儲存起來，之後再從最後暫存的資料或狀態開始接續處理，像這樣從最後的資料開始取出處理，就稱為後進先出（LIFO，Last-In Fist-Out）。";
document.getElementById('description').innerHTML = "請實作一個採取後進先出（LIFO）原則，優先取出最後插入資料的資料結構。";
document.getElementById('input_panel').innerHTML = '<img src="../../problems/lifo/input.svg" width="340"/>';
document.getElementById('output_panel').innerHTML = '<img src="../../problems/lifo/output.svg" width="340"/>';
document.getElementById('algorithm_icon').innerHTML = '<img src="../../icons/algorithms/stack_simulation.svg" width="100"/>';
document.getElementById('atitle').innerHTML = "堆疊";
document.getElementById('atitle_en').innerHTML = "Stack";
document.getElementById('abstract').innerHTML = "堆疊（stack）主要是對資料集進行 push 與 pop 的操作。push 是將元素新增到資料集中，pop 則是取出並刪除最後新增的元素。堆疊的 push、pop 操作符合 LIFO 的原則。本節使用陣列來實作堆疊及 push、pop 操作。";
document.getElementById('explanation').innerHTML = "堆疊的實作使用的是一維陣列與一個指向堆疊頂端的箭頭 top。top 會儲存陣列變數的索引（節點編號）。push 操作會先將 top 加 1，再將給定的資料插入該位置。pop 操作則是先傳回 top 指向的元素，再將 top 減 1。";
document.getElementById('note').innerHTML = "push 操作與 pop 操作的時間複雜度皆與元素數無關，因此為 O(1)。實作時，請務必設計檢查機制，以避免在堆疊為空的狀態（top 為 -1 的狀態）下進行 pop 操作，或在堆疊已滿的狀態下進行 push 操作。<br/><br/>通常堆疊這種資料結構會定義成類別。因為定義成類別後，就能在程式中生成堆疊的物件（object），可以用比較直覺的方式來處理資料（要生成多個物件也很容易。";
document.getElementById('application').innerHTML = "其實日常生活中也有許多堆疊的例子，例如，桌上堆積如山的文件或是自助餐店堆積成疊的餐盤等。堆疊在計算機系統（computer system）中的應用也相當廣泛，例如，遇到中斷（interrupt）等情形時，即可利用堆疊暫存未完成的計算。此外，遞迴函式（Recursive Function）也是利用堆疊實作而成；深度優先搜尋（Depth First Search，第 23 章）與點的凸包（Convex Hull，第 27 章）也都是使用堆疊來實作。";
document.getElementById('structure').innerHTML = '<tr><td style="text-align:center;width:100"><img src="../../icons/structures/A1D.svg" /><br/><br/></td><td class="frame">&nbsp;<img height="160" class="frame_svg" valign="middle" src="space_st.svg" />&nbsp;</td></tr><tr><td></td><td class="caption">一維陣列</td></tr>';
document.getElementById('variable').innerHTML = '<tr><th class="scene_desc" colspan="3">資料</th></tr><tr><td class="symbol"><img src="variable_S.svg" /></td><td>堆疊的元素</td><td class="code">S</td></tr>';
document.getElementById('formula').innerHTML = '<tr><th class="scene_desc" colspan="3">插入與取出資料</th></tr><tr><td class="symbol"><img src="formula_push.svg" /></td><td>新增資料到堆疊頂端。</td><td class="code">S[++top] &larr; x</td></tr><tr><td class="symbol"><img src="formula_pop.svg" /></td><td>從堆疊頂端取出資料並將其刪除。</td><td class="code">return S[top--]</td></tr><tr><td class="symbol"><img src="formula_top.svg" /></td><td>指向堆疊頂端。</td><td class="code">top</td></tr>';
document.getElementById('scheme').innerHTML = '<tr><td style="text-align:center;width:100"><img src="anim_qr.svg" width="80"/></td><td class="frame"><hr class="separator"/><img height="160" class="frame_svg" src="scheme_push.svg" /><p class="caption">新增資料到堆疊中。</p><hr class="separator"/><img height="160" class="frame_svg" src="scheme_pop.svg" /><p class="caption">從堆疊中取出資料。</p></td></tr>';
document.getElementById('scene').innerHTML = '<div><p><b class="scene_desc">插入與取出資料</b><br/><img src="scene_0.svg" alt="堆疊 | 插入與取出資料" title="堆疊 | 插入與取出資料"/></p></div>';
document.getElementById('complexity').innerHTML = '<img src="../../../icons/complexity/const.svg" />';
document.getElementById('prerequisites').innerHTML = '';
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);};